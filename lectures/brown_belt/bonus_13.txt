Как вернуть из функции набор объектов



Ранее мы обсуждали, как передать в функцию набор объектов. Это делалось одним из следующих способов:

передать контейнер по константной ссылке — самый простой, но не очень универсальный;

передать два итератора или (в светлом будущем) range — более универсальный, но чуть менее прозрачный;

передать span — для тех случаев, когда необходимо, чтобы элементы хранились в памяти подряд.

Здесь же мы обсудим различные способы возвращения набора объектов одного типа из функции.

Вернуть контейнер
Совершенно очевидно, что если функция должна построить, например, unordered_set объектов для быстрого поиска в нём, надо просто вернуть unordered_set и больше ничего не выдумывать.

На практике всё же чаще встаёт вопрос о том, как стоит вернуть набор объектов, по которому нужно всего лишь уметь проитерироваться. И самый простой ответ на этот вопрос — вернуть вектор.

Итак, возвращайте из функции вектор объектов, если вам не требуется серьёзная универсальность, как при написании библиотеки, и сам вектор удовлетворяет всем требованиям задачи.

Вернуть view
Вектор подходит для возврата из функции набора объектов, которые функция создала специально в этом вызове и готова отдать их и забыть. Но бывают ситуации, когда функция или метод хочет дать возможность проитерироваться по набору объектов, не передавая владение самими объектами и не выделяя дополнительную память под контейнер.

Ссылка на контейнер
Конечно же, самый простой способ это сделать — вернуть константную ссылку на контейнер. Так мы делали, например, в решении задачи «Таблица» из «Красного пояса»:



template <typename T>
class Table {
 private:
  vector<vector<T>> data;

 public:
  // ...

  const vector<T>& operator [] (size_t idx) const {
    return data[idx];
  }

  // ...
};



(table[i] вернёт ссылку на вектор: по нему можно как проитерироваться, так и обратиться к конкретному элементу по номеру.)

string_view
Не всегда удобно возвращать из метода ссылку на конкретный контейнер, поскольку это может усложнить изменение способа хранения в функции: меняя, например, вектор на дек, вам нужно будет не только изменить возвращаемое значение всех методов, возвращавших ссылку на вектор, но и поправить весь код, который, вызывая эти методы, сохранял куда-то ссылку на этот вектор.

Именно для этого существуют различные view-типы, позволяющие сослаться на набор элементов, не владея им. С одним из них мы познакомились в предыдущем курсе — это класс string_view. В качестве возвращаемого значения он выступал, например, в задаче Translator:



class Translator {
public:
  void Add(string_view source, string_view target);
  string_view TranslateForward(string_view source) const;
  string_view TranslateBackward(string_view target) const;

private:
  map<string_view, string_view> forward_dict;
  map<string_view, string_view> backward_dict;
  deque<string> data;
}



Как мы уже обсуждали, string_view универсальнее простой ссылки на string и может ссылаться как на подстроку, так и на строковую константу в кавычках (вроде такой: "i'm a string literal").

span
Другой пример такого класса — span, позволяющий сослаться на диапазон любых объектов, расположенных в памяти подряд. Его можно было бы применить в задаче AirportCounter из 3-го курса, если бы приведённые нами бенчмарки пропускали реализацию класса, хранящую набор пар (аэропорт, количество):



template <typename TAirport>
class AirportCounter {
public:
  AirportCounter();

  template <typename TIterator>
  AirportCounter(TIterator begin, TIterator end);

  size_t Get(TAirport airport) const;
  void Insert(TAirport airport);
  void EraseOne(TAirport airport);
  void EraseAll(TAirport airport);

  using Item = pair<TAirport, size_t>;
  static const size_t SIZE = static_cast<size_t>(TAirport::Last_);
  using Items = array<Item, SIZE>;

  // требовалось получить некоторый объект, по которому можно проитерироваться,
  // получив набор объектов типа Item - пар (аэропорт, количество),
  // упорядоченных по аэропорту
  const Items& GetItems() const {
    return items_;
  }

private:
  Items items_;
};



Здесь приведён вариант с возвращением константной ссылки на массив. Но есть дешёвый способ сделать эту функцию чуть более гибкой: достаточно возвращать диапазон Item в виде span: 



template <typename TAirport>
span<Item> AirportCounter<TAirport>::GetItems() const {
  return items_;
}



Теперь при необходимости можно изменить хранилище items_ на вектор, не меняя код, использующий GetItems.

Range
И string_view, и span ссылаются на диапазон элементов, расположенных в памяти подряд. Но что делать, если проитерироваться по объектам я могу, но их расположение в памяти не позволяет использовать span? Такая ситуация возникала в методе Domain::GetParts в задаче «Запрещённые домены»:



template <typename It>
class Range {
public:
  Range(It begin, It end) : begin_(begin), end_(end) {}
  It begin() const { return begin_; }
  It end() const { return end_; }

private:
  It begin_;
  It end_;
};

class Domain {
public:
  explicit Domain(string_view text) {
    vector<string_view> parts = Split(text, ".");
    parts_reversed_.assign(rbegin(parts), rend(parts));
  }

  size_t GetPartCount() const;

  // здесь можно было бы вернуть span
  auto GetReversedParts() const {
    return Range(begin(parts_reversed_), end(parts_reversed_));
  }
  // а здесь — нет
  auto GetParts() const {
    return Range(rbegin(parts_reversed_), rend(parts_reversed_));
  }

  bool operator==(const Domain& other) const;

private:
  vector<string> parts_reversed_;
};



Как видите, здесь возникла задача вернуть набор объектов, описывающийся двумя итераторами rbegin(parts_reversed_) и rend(parts_reversed_). Это можно было бы сделать с помощью пары (как делает алгоритм std::equal_range), но тогда мы бы не могли проитерироваться по этому набору с помощью простой конструкции for (string_view part : domain.GetParts()) { /* ... */ }. Поскольку известно, что такой цикл for требует от итерируемого объекта лишь методов begin и end, мы вернули те же два итератора, но обернув их в класс Range.

Напомним, что использование ranges позволило отказаться от самописного класса Range и даже от явного использования обратных итераторов:



class Domain {
public:
  explicit Domain(string_view text) {
    vector<string_view> parts = Split(text, ".");
    parts_.assign(begin(parts), end(parts));
  }

  size_t GetPartCount() const;

  auto GetParts() const {
    return view::all(parts_);
  }
  auto GetReversedParts() const {
    return view::reverse(parts_);
  }

  bool operator==(const Domain& other);

private:
  vector<string> parts_;
};



Итак, вернуть из функции два итератора, обёрнутых в Range, — это наиболее универсальный способ вернуть набор объектов, не передавая владение ими (как ещё говорят, «вернуть view набора объектов»).

Принять выходной итератор
Вернёмся к вопросу о том, как вернуть набор объектов, передав владение ими — грубо говоря, вернуть и забыть. Вернуть контейнер с элементами — простое и понятное решение, но в некоторых ситуациях от функции хочется большей гибкости. Более универсальный способ вы уже встречали в стандартной библиотеке — например, при работе с алгоритмом merge в задаче «Сортировка слиянием»:



template <typename RandomIt>
void MergeSort(RandomIt range_begin, RandomIt range_end) {
  // 1. Если диапазон содержит меньше 2 элементов, выходим из функции
  int range_length = range_end - range_begin;
  if (range_length < 2) {
    return;
  }
  
  // 2. Создаем вектор, содержащий все элементы текущего диапазона
  using T = typename iterator_traits<RandomIt>::value_type;
  vector<T> elements(range_begin, range_end);
  
  // 3. Разбиваем вектор на две равные части
  auto mid = elements.begin() + range_length / 2;
  
  // 4. Вызываем функцию MergeSort от каждой половины вектора
  MergeSort(elements.begin(), mid);
  MergeSort(mid, elements.end());
  
  // 5. С помощью алгоритма merge сливаем отсортированные половины
  // в исходный диапазон
  // merge -> http://ru.cppreference.com/w/cpp/algorithm/merge
  merge(elements.begin(), mid, mid, elements.end(), range_begin);
}



Как и другие подобные алгоритмы, merge возвращает набор элементов согласно некоторой своей логике. И эта логика по сути просто «генерирует» элементы по одному, совершенно не нуждаясь в понимании того, в какой контейнер эти элементы будут складываться (и будут ли вообще). И вот такая универсальность, абстрагированная от конкретного контейнера, ожидаемо реализована с помощью итераторов — в данном случае с помощью выходного итератора, передаваемого в merge 5-м аргументом.

Рассмотрим различные способы сохранить результат вызова merge, передавая туда разные выходные итераторы.

Итератор на контейнер



array<T, 100000> result;
const auto result_end = merge(/* ... */, begin(result));
// результат лежит в полуинтервале [begin(result), result_end)




Можно передать итератор на неконстантный контейнер — например, на массив. Здесь наверняка пригодится значение, возвращаемое подобными функциями, — конец выходного диапазона.

inserter и back_inserter
Напомним, что в качестве выходного итератора можно передать специальный back_insert_iterator, при записи в который происходит push_back в указанный контейнер:



vector<T> result;
merge(/* ... */, back_inserter(result));
// результат лежит в векторе result




  Для вызова метода insert — например, для множества — существует insert_iterator, создаваемый с помощью функции inserter:  



set<T> result;
merge(/* ... */, inserter(result, end(result)));
// результат лежит во множестве result



Обратите внимание, что здесь выходным итератором называется уже не объект, который указывает на некоторое место контейнера, начиная с которого можно записывать результат. На примере inserter и back_inserter видно, что от выходного итератора требуется лишь каким-то образом обрабатывать очередное сохраемое значение. Причём делать это нужно хитро — при операциях вида *iter = value. Реализованы такие итераторы довольно интересным образом: operator++ и даже operator* для них не делают ничего, зато operator=(const T&) обрабатывает очередное значение типа T, вызывая, например, push_back.

ostream_iterator
Ещё один пример подобного итератора — итератор вывода в поток:



merge(/* ... */, ostream_iterator<T>(cout, " "));
// результат выведен в cout через пробел



  С помощью ostream_iterator можно вывести элементы контейнера в поток с помощью вызова copy:  



vector<int> numbers = {2, 1, 9, 2};
copy(begin(numbers), end(numbers), ostream_iterator<int>(cout, " "));



Но проще всё же написать for. 

Использование выходного итератора: итоги
Итак, функции, возвращающие элементы с помощью выходного итератора довольно универсальны: с их помощью можно как перезаписать результатом существующий контейнер, так и создать новый или даже вывести результат непосредственно в поток.

Реализовать их не сложнее, чем возврат контейнера элементов: достаточно каждый новый элемент «отдавать» итератору с помощью конструкции *out_iter = yet_another_value. Продемонстрируем это на примере функции ReadDomains. Так выглядел вариант с возвратом вектора:



vector<Domain> ReadDomains(istream& in_stream = cin) {
  vector<Domain> domains;

  size_t count;
  in_stream >> count;
  domains.reserve(count);

  for (size_t i = 0; i < count; ++i) {
    string domain_text;
    in_stream >> domain_text;
    domains.emplace_back(domain_text);
  }
  return domains;
}



При использовании выходного итератора код станет даже чуть компактнее:  



template <typename OutputIterator>
OutputIterator ReadDomains(OutputIterator result_it, istream& in_stream = cin) {
  size_t count;
  in_stream >> count;

  for (size_t i = 0; i < count; ++i) {
    string domain_text;
    in_stream >> domain_text;
    *result_it++ = Domain(domain_text);
  }
  return result_it;
}


С другой стороны, из-за разнообразия сценариев использования таких функций страдает простота использования. Представьте себе, что хотите вызвать функцию ReadDomains и проитерироваться по полученным доменам. Вот так это будет выглядеть при возврате вектора:  



for (const Domain& domain : ReadDomains()) {
  // ...
}



Если же ReadDomains будет работать через выходной итератор, понадобится пара лишних строк:  



vector<Domain> domains;
ReadDomains(back_inserter(domains));
for (const Domain& domain : domains) {
  // ...
}



Мало того, что создание вектора перекладывается на плечи вызывающего кода, так ещё и пропадает возможность вызова reserve: возвращая вектор, функция чётко понимала, с каким контейнером работает, и её разработчик мог вызвать reserve; универсальный же вариант работает с итератором и про контейнер ничего не знает, а вызывающий код, в свою очередь, не знает предполагаемый размер контейнера и reserve вызвать не может.

Таким образом, у универсальных функций, использующих выходные итераторы, есть свои минусы: громоздкость некоторых сценариев вызова и недостаток знаний про контейнер в самой функции.

Принять callback
Если вы знакомы с колбеками на примере других языков, то можете поинтересоваться: нельзя ли вместо выходных итераторов, назначение которых заключается лишь в последовательной обработке возвращаемых объектов, использовать функциональный объект?

Переделать функцию соответствующим образом несложно:



template <typename ResultConsumer>
void ReadDomains(ResultConsumer result_consumer, istream& in_stream = cin) {
  size_t count;
  in_stream >> count;

  for (size_t i = 0; i < count; ++i) {
    string domain_text;
    in_stream >> domain_text;
    result_consumer(Domain(domain_text));
  }
}



С другой стороны, стандартные сценарии вида «получить набор объектов и проитерироваться по нему» усложняются. Так может выглядеть заполнение существующего вектора:



vector<Domain> domains(MAX_DOMAIN_COUNT);
auto it = begin(domains);
ReadDomains([&it](Domain domain) { *it++ = move(domain); });
domains.erase(it, end(domains));



Для таких ситуаций вариант с выходным итератором подошёл бы лучше.

Сценарии с серией push_back выглядят чуть приятнее: вместо back_inserter достаточно написать свою простую лямбду.


vector<Domain> domains;
ReadDomains([&domains](Domain domain) { domains.push_back(move(domain)); });



И не нужно тайных знаний про ostream_iterator:  



ReadDomains([](const Domain& domain) { cout << domain << " "; });



(Хотя нельзя не признать, что сценарий «считать домены и тут же вывести» выглядит странно.)

Наконец, в концепцию колбеков легко укладывается любое экзотическое желание по обработке элементов без складывания их в контейнер. Например, в той же задаче «Запрещённые домены» можно было бы не выделять память под домены-запросы.

Исходный код функции main был таким:



const vector<Domain> banned_domains = ReadDomains();
const vector<Domain> domains_to_check = ReadDomains();
PrintCheckResults(CheckDomains(banned_domains, domains_to_check));



Если же представить себе callback-версию ReadDomains, избавиться от второго вектора можно примерно так:  



vector<Domain> banned_domains;
ReadDomains(
    [&banned_domains](Domain domain) { banned_domains.push_back(move(domain)); }
);

const DomainChecker checker(begin(banned_domains), end(banned_domains));
ReadDomains([&checker](const Domain& domain) {
  cout << (checker.IsSubdomain(domain) ? "Bad" : "Good") << "\n";
});



Вся логика перемешана, читать тяжело, лямбды не покрыты тестами, зато достаточно элегантно и не пришлось радикально менять функцию ReadDomains и тесты на неё. На выходных итераторах реализовывать такое было бы менее приятно: пришлось бы создавать отдельный класс выходного итератора, запись в который вызывала бы IsSubdomain и выводила бы результат. С учётом того, что итераторы принято передавать по значению, такая задача становится сама по себе довольно нетривиальной.  

Итоги
Для возврата из функции набора объектов без передачи владения ими есть следующие варианты:

Вернуть ссылку на контейнер: не очень гибко и нарушает инкапсуляцию.

Вернуть span или string_view: неплохо, но подходит только для определённых контейнеров.

Вернуть самописный Range из двух итераторов (или дождаться C++20 и использовать ranges): максимально гибко, но иногда подойдут и более простые варианты.

Если же функция возвращает набор объектов с передачей владения, градация вариантов от простого к сложному следующая:

Вернуть контейнер: просто и понятно, но расходует память под хранение элементов.

Принять выходной итератор, записать в него и вернуть новое состояние: совместимо со стандартной библиотекой, но немного громоздко в месте вызова и тяжело кастомизируемо под сложные ситуации.

Принять callback, потребляющий элементы: несовместимо со стандартной библиотекой и громоздко для простых случаев, но легко кастомизируемо.
